# 算法

我们平时面试的时候, 通常会问道我们算法的面试题, 因为一个算法的能力高低,最能体现一个程序员的基本功是否扎实, 基本功扎实的人, 无论我们做工程, 还是做算法, 都不会差到哪里去啊



我一直在跟身边的朋友强调,我们在解决问题的, 或者写程序的时候, 我们先要理清楚我们的思路, 思路理清楚了, 这个才是最最重要的, 把思路转变成代码能力也很重要, 但是我自己更加注重解题的思路, 今天有空, 借鉴苏勇老师的文章, 来整理一下相关算法和数据结构的算法题, 帮助大家在面试中拿到不错的成绩



好了leetcode那么多的题, 从原来的一两百道, 到现在的一千多道, 你一个人不一定可以啃完, 啃完以后, 你也不一定可以掌握, 让就赶紧来关注我吧, 让我们每天进步一点点.

## 1. 常见数据结构

我们常用的数据结构主要由下面这些:

- 数组、字符串
- 链表
- 栈
- 队列
- 双端队列
- 树



今天我们就来一下数组, 字符串



字符串的转化

数组和字符串是最基本的数据结构，在很多编程语言中都有着十分相似的性质，而围绕着它们的算法面试题也是最多的。

很多时候，在分析字符串相关面试题的过程中，我们往往要针对字符串当中的每一个字符进行分析和处理，甚至有时候我们得先把给定的字符串转换成字符数组之后再进行分析和处理。

<img src="/Users/lingjing/公众号/算法/image1.gif" alt="image1" style="zoom:50%;" />

**解法：**用两个指针，一个指向字符串的第一个字符 a，一个指向它的最后一个字符 m，然后互相交换。交换之后，两个指针向中央一步步地靠拢并相互交换字符，直到两个指针相遇。这是一种比较快速和直观的方法。

注意：由于无法直接修改字符串里的字符，所以必须先把字符串变换为数组，然后再运用这个算法。



数组的优缺点要掌握一种数据结构，就必须要懂得分析它的优点和缺点。

数组的优点在于：

- 构建非常简单
- 能在O(1)的时间里根据数组的下标（index）查询某个元素

而数组的缺点在于：

- 构建时必须分配一段连续的空间
- 查询某个元素是否存在时,需要遍历整个数组, 耗费O(n)的时间
- 删除添加某个元素时, 童谣需要耗费O(n)的时间

## 2. 例题解析:

leetcode 242题 [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = "anagram", t = "nagaram"
输出: true
示例 2:

输入: s = "rat", t = "car"
输出: false
说明:
你可以假设字符串只包含小写字母。

字母异位词，也就是两个字符串中的相同字符的数量要对应相等。例如，s等于“anagram”，t等于“nagaram”，s和t就互为字母异位词。因为它们都包含有三个字符a，一个字符g，一个字符m, 一个字符n, 一个字符r. 而当s为"rat", t为"car"的时候, s和t不互为字母异位词

## 3. 解题思路

一个重要的前提是, 假设两个字符串只包含小写字母, 小写字母一共也就26个, 因此:

1. 可以利用两个长度为26的字符数组来统计两个字符串中小写字母出现的次数, 然后在对比是否相等
2. 可以值利用一共长度为26的字符数组, 将出现在字符串s里的字符个数加1, 而出现在字符串t里面的字符个数减1, 最后判断每个小写字母的个数是否为0

## 4. 官网给的答案

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    int[] counter = new int[26];
    for (int i = 0; i < s.length(); i++) {
        counter[s.charAt(i) - 'a']++;
        counter[t.charAt(i) - 'a']--;
    }
    for (int count : counter) {
        if (count != 0) {
            return false;
        }
    }
    return true;
}
```

官网这里很巧妙的使用了字符char这个类型, 因为所有的类型 - 'a', 都会是一个整数, 默认所有的值都为0, 如果我自己解题, 我可能想不到这个, 因为使用范围也不是很广, 我可能使用HashMap的方式来做.



## 5.自己的解法

```java
public boolean isAnagram(String s, String t) {
  if ( s.length() != t.length()) {
    return false;
  }
  HashMap<String, Integer> res = new HashMap<String, Integer>();
  for (int i = 0; i < s.length(); i++) {
    if (res.get(s[i]) == null) {
      res.put(s[i], 1);
    } else {
      res.put(s[i], res.get(s[i]) + 1)
    }
    if (res.get(t[i]) == null) {
      res.put(t[i], -1);
    } else {
      res.put(t[i], res.get(t[i]) - 1)
    }
  }
  
  for (Integer value : res.values()) {
    if (value != 0) {
      return false;
    }
  }
  return true;
}
```

