# 链表(LinkedList)

单链表: 链表中的每个元素实际上是一个单独的对象, 而所有对象都通过每个元素中的引用字段链接在一起

双向链表: 于单链表不同的是, 双链表的每个节点中都包含有两个引用字段

## 1. 链表的优点:

- 链表能灵活的分配内存空间
- 能在O(1)时间内删除后者添加元素, 前提是该元素的前一个元素已知, 当然也取决于是单链表还是双链表, 在双链表中, 如果对改元素的后一个元素, 同样可以在O(1)时间内删除后者添加改元素

## 2. 链表的缺点: 

- 不像数组能通过下标迅速读取元素, 每次都要从链表头开始一个一个读取;

- 查询第K个元素需要事件O(K)时间

## 3. 应用场景

如果要解决的问题里面, 需要快速查询, 链表可能就不合适了, 如果应用场景中, 如果元素的个数不确定, 可以随时的增减, 链表可能就比较合适, 而如果数据元素大小确定, 删除插入的操作并不多, 那数组可能更加合适.

## 4. 经典解法

1. 使用快慢指针: 如链表的反转, 寻找倒数第K个元素, 寻找链表中间位置的元素, 判断链表是否有环等等
2. 构建一个虚假的链表头: 

一般用在要返回新的链表的题目中, 比如: 给定两个排好序的链表, 要求将他们整合在一起并排好序, 又比如: 将一个聊表的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表, 聊表的头一半是奇数, 后一般是偶数

在这类问题中, 如果不用一个虚假的链表头, 那么在创建新链表的第一个元素时, 我们都得要判断一下链表的头指针是否为空, 也就是要多些一条if else语句. 比较简洁的写法是创建一个空的链表头, 直接在后面添加元素即可, 最后返回这个空的链表头的下一个节点即可

建议: 在解决链表的题目时, 可以在纸上或者白板上画出节点直接的相互关系, 然后画出修改的方法, 既可以帮助你分析问题, 又可以在面试的时候, 帮助面试官清楚的看到你的思路

# 5. 例题解析

leetcode 25题, 给我一个链表, 每K个节点一组进行翻转, 请你返回翻转的链表, K是一个整数, 他的值小于或者等于链表的长度. 如果节点总数不是k的整数倍, 那么请将最后剩余的界定啊保持原有顺序

说明: 

- 你的算法只能使用常数的额外空间

- 你不能只能单纯的改变节点内部的值, 而是需要实际的进行节点互换.

示例: 

给定这个链表: 1->2->3->4->5

当k=2时, 应当返回: 2->1->4->3->5

当k=3时, 应当返回: 3->2->1->4->5

在官网找到的解题步骤:

一图胜千言，根据图片看代码，马上就懂了

步骤分解:

1. 链表分区为已翻转部分+待翻转部分+未翻转部分
2. 每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定
3. 需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来
4. 初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾
5. 经过k此循环，end 到达末尾，记录待翻转链表的后继 next = end.next
6. 翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环
7. 特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可
8. 时间复杂度为 O(n*K)O(n∗K) 最好的情况为 O(n)O(n) 最差的情况未 O(n^2)O(n 2)
9. 空间复杂度为 O(1) 除了几个必须的节点指针外，我们并没有占用其他空间

![image2](/Users/lingjing/公众号/算法/image2.png)

# 6. 代码示例

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(0);
  // 先把元素都穿起来
    dummy.next = head;

    ListNode pre = dummy;
    ListNode end = dummy;

    while (end.next != null) {
      // 先找到end元素,
        for (int i = 0; i < k && end != null; i++) end = end.next;
      // 如果不符合长度的条件, 直接返回
        if (end == null) break;
      // 翻转列表之前, 需要把链表的前后元素都需要记录下来, 
        ListNode start = pre.next;
        ListNode next = end.next;
      // 必须先把end的next指定为空, 否则在子方法中没法结束
        end.next = null;
      // 把开始对象, 指向新链表的第一个ListNode
        pre.next = reverse(start);
      // 此时的start元素, 就是翻转以后的最后一个元素, 下面是元素连接起来
        start.next = next;
        pre = start;

        end = pre;
    }
    return dummy.next;
}

// 翻转列表以后, 返回的新的链表的第一个元素
private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode curr = head;
  // 从1-2-3, 进行循环, 更改指针指向, pre指向的是最后的一个对象, 即3对象
    while (curr != null) {
        ListNode next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
}

```

自己定义的ListNode

```java
public class ListNode {
    public int val;
    public ListNode next;
    public ListNode(int x) {
        val = x;
        next = null;
    }
}
```

