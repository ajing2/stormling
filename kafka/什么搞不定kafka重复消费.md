# 什么? 搞不定kafka重复消费?

首先申明, 这篇文章不是我写的, 这个是一个大佬, 我前面一直提到的一个老师, 孙玄老师写的, 自己学习完以后还是特别受益的, 感觉思路一下开阔了.内心觉得是非常的好, 还记得我前段时间学习到的一个学习方法吗, 费曼学习法, 如果我想掌握老师讲的这个知识点, 不仅仅是看完以后, 而是要试着总结出来, 并可以给大家讲清楚, 原文链接请大家参考: https://mp.weixin.qq.com/s/K-UciY4iqfMMBErjpQA75Q

玄姐, 他到底是谁呢, 他好像有一大推的title, 奈学教育 CEO，毕业于浙江大学，现任转转公司首席架构师，技术委员会主席，大中后台技术负责人（交易平台、基础服务、智能客服、基础架构、智能运维、数据库、安全、IT 等方向）；前58集团技术委员会主席，高级系统架构师；前百度资深研发工程师；够多的吧, 其实让我总结一下的话, 就是牛逼, 很牛逼就是了.呵呵......

好我们回到我们的正题上, 我们先来来说说, kafka重复消费的问题, 其实小编在面试的时候或者是在刷面试题的时候, 就遇到过这个问题, 如果回答的不太好, 真的让我们面试的结果不尽人意.



其实在开发的时候, 我们在设计程序的时候, 比如考虑到网络故障等一些异常的情况, 我们都会设置消息的重试次数, 

可能还有其他可能出现消息重复, 那我们应该如何解决呢?

老师给了三个方案, 供大家参考

## 1. 方案一:

给每个消息都设置一个独一无二的uuid, 所有的消息, 我们都要存一个uuid, 我们在消费消息的时候, 首先去持久化系统中查询一下, 看这个看是否以前消费过, 如没有消费过, 在进行消费, 如果已经消费过, 丢弃就好了, 老师用一个很清晰的图, 表明了这种方案

![kafka101](/Users/lingjing/公众号/kafka/kafka101.png)

## 2. 方案二:

利用幂等

我觉得第二种方法, 就是老师牛逼的地方, 居然把数学的方法拿过来, 做这么长时间的程序员, 都把数学忘完了, 但是老师能把这个很好的运用过来, 给自己打开新的思路

幂等（Idempotence）在数学上是这样定义的，如果一个函数 f(x) 满足：f(f(x)) = f(x)，则函数 f(x) 满足幂等性。

这个概念被拓展到计算机领域，被用来描述一个操作、方法或者服务。一个幂等操作的特点是，其任意多次执行所产生的影响均与一次执行的影响相同。一个幂等的方法，使用同样的参数，对它进行多次调用和一次调用，对系统产生的影响是一样的。所以，对于幂等的方法，不用担心重复执行会对系统造成任何改变。

我们举个例子🌰来说明一下。在不考虑并发的情况下，“将 X 老师的账户余额设置为 100 万元”，执行一次后对系统的影响是，X 老师的账户余额变成了 100 万元。只要提供的参数 100万元不变，那即使再执行多少次，X 老师的账户余额始终都是 100万元，不会变化，这个操作就是一个幂等的操作。

再举一个例子🌰，“将 X 老师的余额加 100 万元”，这个操作它就不是幂等的，每执行一次，账户余额就会增加 100 万元，执行多次和执行一次对系统的影响（也就是账户的余额）是不一样的。

所以，通过这两个例子，我们可以想到如果系统消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题了，因为同一条消息，消费一次和消费多次对系统的影响是完全一样的。也就可以认为，消费多次等于消费一次。

那么，如何实现幂等操作呢？最好的方式就是，从业务逻辑设计上入手，将消费的业务逻辑设计成具备幂等性的操作。但是，不是所有的业务都能设计成天然幂等的，这里就需要一些方法和技巧来实现幂等。

下面我们介绍一种常用的方法：**利用数据库的唯一约束实现幂等。**

例如，我们刚刚提到的那个不具备幂等特性的转账的例子：将 X 老师的账户余额加 100 万元。在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。

首先，我们可以限定，对于每个转账单每个账户只可以执行一次变更操作，在分布式系统中，这个限制实现的方法非常多，最简单的是我们在数据库中建一张转账流水表，这个表有三个字段：转账单 ID、账户 ID 和变更金额，然后给转账单 ID 和账户 ID 这两个字段联合起来创建一个唯一约束，这样对于相同的转账单 ID 和账户 ID，表里至多只能存在一条记录。

这样，我们消费消息的逻辑可以变为：“在转账流水表中增加一条转账记录，然后再根据转账记录，异步操作更新用户余额即可。”在转账流水表增加一条转账记录这个操作中，由于我们在这个表中预先定义了“账户 ID 转账单 ID”的唯一约束，对于同一个转账单同一个账户只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作。

![kafka102](/Users/lingjing/公众号/kafka/kafka102.png)

自己的理解: 数据库的唯一索引大家应该都用过, 这个时候我们需要设计一个好的一个id, 来满足这个需求, 就是不管这个sql插入多少次, 就是只能插入一条数据, 执行N遍, 还是等于执行一遍, 因为其他的次数都应数据库的唯一约束, 都没有执行成功. 我觉得第二种方案的思想真的是很重要.

第二种方案, 我认为, 中间加入了数据, 相当于是让我们的数据库给我们做了一个去重的操作, 一边是需要往数据库总写, 一边是要去数据库总读, 这种情况在大流量的消息下, 是否会对数据库造成压力呢?

## 3. 方案三

为更新的数据设置前置条件另外一种实现幂等的思路是，给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据，在更新数据的时候，同时变更前置条件中需要判断的数据。

这样，重复执行这个操作时，由于第一次更新数据的时候已经变更了前置条件中需要判断的数据，不满足前置条件，则不会重复执行更新数据操作。

比如，刚刚我们说过，“将 X 老师的账户的余额增加 100 万元”这个操作并不满足幂等性，我们可以把这个操作加上一个前置条件，变为：“如果X老师的账户当前的余额为 500万元，将余额加 100万元”，这个操作就具备了幂等性。

对应到消息队列中的使用时，可以在发消息时在消息体中带上当前的余额，在消费的时候进行判断数据库中，当前余额是否与消息中的余额相等，只有相等才执行变更操作。

但是，如果我们要更新的数据不是数值，或者我们要做一个比较复杂的更新操作怎么办？用什么作为前置判断条件呢？更加通用的方法是，给你的数据增加一个版本号属性，每次更数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时将版本号 +1，一样可以实现幂等。

个人理解: 第三种方案本质上是cas乐观锁。一般我们在设计程序的时候, 都会把这个版本号用过我们的update_time这个字段, 这种方案, 就是我们拿到消息以后, 要跟我们原来的消息进行一个对比, 特别是版本号的一个对比, 如果一样, 那就进行操作, 只要不一样, 那就直接扔掉就好, 要么是过期或者还是重复了.



以上三种方案,我看完以后收货还是很大的, 希望大家也能看到!如果大家觉得不错, 可以关注玄姐的公众号: 架构之美