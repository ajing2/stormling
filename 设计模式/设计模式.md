# 面向对象设计原则概述

一说到面对对象的设计原则, 我就有点脑袋大, 向来就不擅长这个文字性的理解, 但是这些思维却很重要, 首先, 就是面试离不来, 总是会被问道, 这个直接影响到你的钱包的后端, 这不得不看看了, 大家都跟钱没仇吧, (嘿嘿), 

其次, 这个在思想上很重要, 为什么呢? 我们在写代码的时候, 应该是先设计好架构, 分析好逻辑, 应该用什么方法, 最后的一步才是我们去写代码.

最后, 如果你去看一些源码的时候, 很多时候就是都会跟你扯设计原则, 设计模式, 我当时就是脸的懵逼样, 就想问问老天, 谁能告诉我, 好下面, 我们就来看看七大设计原则

对于面向对象软件系统的设计而言, 在支持可维护性的同时, 提高系统的可复用性是一个至关重要的问题, 如何同时提高一个软件系统的可维护性和可复用性是面对对象设计需要解决的核心问题之一, 在面向对象设计中, 可维护性的复用是以设计原则为基础的. 每一个原则都蕴含一些面向对象设计的思想, 可以从不同的角度提升一个软件结构的设计水平

对向对象设计原则为支持可维护性复用而诞生, 这些原则蕴含在很多设计模式中, 他们从很多设计方案中总结出的指导性原则, 面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一, 在设计模式的学习中, 大家经常会看到诸如 "xxx模式符合XXX原则", "XXX模式违反了XXX原则"这样的语句.

最常见的7种面向对象设计原则如下表所示:

|                    设计原则名称                    |                       定义                       |
| :------------------------------------------------: | :----------------------------------------------: |
| 单一职责原则(Single Responsibility Principle, SRP) |       一个类只负责一个功能领域中的相应职责       |
|        开闭原则(Open-Closed Principle, OCP)        |        软件实体应对扩展开放, 而对修改关闭        |
|  里氏代换原则(Liskov Substitution Principle, LSP)  | 所有引用基类对象的地方能够透明地使用其子类的对象 |
| 依赖倒转原则(Dependence Inversion Principle, DIP)  |     抽象不应该依赖于细节, 细节应该依赖于抽象     |
| 接口隔离原则(Intereface Segreation Principle, ISP) |     使用多个专门的接口, 而不是用单一的总接口     |
|    合成复用原则(Composite Reuse Principle, CRP)    |   尽量使用对象组合, 而不是继承来达到复用的目的   |
|          迪米特法则(Law of Demeter, LOD)           | 一个软件实体应当尽可能少的与其他实体发生相互作用 |

------



# 面向对象七大设计原则

## 1. 单一职责原则

单一原则个人认为, 就是在设计之初, 就是把不同功能的类进行区分, 不同类的功能进行划分, 越小越细致越好, 这样我们在对待不同的功能, 不能的作用, 划分不同的类, 

举个很简单的例子: 我们在使用sonar扫描的时候, 推荐使用sonarLint插件, 如果你的一个方法超过15行, 就会提示你方法太大, 算一个代码异味, 就是要把我们方法进行拆分, 越细越好, 方法的行数不要超过15行, 这个也是<<阿里巴巴开发手册>>的要求.这个仅仅是对方法的一个要求, 那对于我们的类进行设计呢, 功能划分上要加要细致, 要比方法这个更加细致一些.



单一职责原则是最简单的面向对象设计原则, 它用于控制类的粒度大小, 单一职责原则定义如下:

```
单一职责原则(sINGLE Responsibility Principle, SRP): 一个类只负责一个功能领域中的相应职责, 或者可以定义为: 就一个类而言, 应该只有一个引起它变化的原因.
```



单一职责原则告诉我们:一个类不能太“累”!在软件系统中，一个类(大到模块，小到方法)承担的职责越多，它
被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可
能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装
在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。



单一职责原则是实现 的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责 并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。



举例: 我们在java开发过程中, 经常使用到各个层, 比如: controller层, service层, manager层, dao层, mapper层, 等等这些, 其实这个层上的划分, 就符合我们的单一原则, 不同的层, 不同, 做不同的事情, 

比如我们做devops后台的开发, jira, sonar, gitlab, 这些, 这些很自然的, 你就需要设计不同的controller, 下面的层依次划分, 跟着站队就好了!

有没有get到.就是这么简单.

## 2. 开闭原则

开闭原则是面向对象的可服用设计的第一块基石, 它是最重要的面向对象设计原则, 开闭原则由Bertrand meyer于1988年提出, 其定义如下: 

```
开闭原则(Open-Closed Principle, OCP): 一个软件实体应当对扩展开发, 对修改关闭, 即软件实体应该尽量在不能修改原有代码的情况下进行扩展
```

在开闭原则的定义中， 。

```
任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求
时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行
扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随
着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重
要。
```

为了满足开闭原则，需要对系统进行抽象化设计，**抽象化是开闭原则的关键** 。在Java、C#等编程语言中，可以为系 统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了 接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须 对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统 的功能，达到开闭原则的要求。

我们在java开发中, 在service层, manager层, dao层, 一般的规范需要我们定义一个接口的, 即interface, 然后在写我们具体实现类的代码, 这样的好处就是如果有不同的实现类, 我们只需要实现接口就好了, 并不需要更改我们原来写的实现类的代码.

## 3. 里式替换原则

里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士 教授和卡内基·梅隆大学 Jeannette Wing教授于1994年提出。其严格表述如下:如果对每一个类型为S的对象o1，都有类型为T的对象o2， 使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。这个定义 比较拗口且难以理解，因此我们一般使用它的另一个通俗版定义:

```
里氏代换原则(Liskov Substitution Principle, LSP):所有引用基类(父类)的地方必须能透明地使用其子类的对象
```

里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象, 程序将不会产生任何的报错和异常, 反过来则不成立, 如果一个软件实体使用的是一个子类对象的话, 那么它不一定能够使用基类对象. 

里式替换原则是实现开闭原则的重要方式之一, 由于使用基类对象的地方都可以使用子类对象, 因此在程序中尽量使基类类型来对对象进行定义, 而在运行时在确定其子类类型, 用子类对象来替换父类对象

在使用里式替换原则时需要注意以下几个问题: 

1. 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证 系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声 明，则无法在以父类定义的对象中使用该方法。
2. 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现 在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原 有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之 一。
3. Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、 纯语法意义上的检查，但Java编译器的检查是有局限的

## 4. 依赖倒转原则

如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽 象化的具体实现。依赖倒转原则是 在1996年为“C++Reporter”所写的专栏Engineering Notebook的第三篇，后来加入到他在2002年出版的经典著作 "Agile Software Development, Principles, Patterns, and Practices"一书中. 依赖倒转原则定义如下:

```
依赖倒转原则(Dependency Inversion Principle, DIP), 抽象不应该依赖于细节, 细节应当依赖于抽象, 换言之, 要针对接口编程, 而不是针对实现编程
```

依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。



在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求



在实现依赖倒转原则时, 我们需要针对抽象层编程, 而将具体类的对象通过依赖注入的方式注入到其他对象中, 依赖注入是指当一个对象要与其他对象发生依赖关系时, 通过抽象类来注入所依赖的对象, 常用的注入方式有三种, 分别是: 构造注入, 设置注入(Setter注入)和接口注入. 构造注入是指通过构造函数来传入具体类的对象, 设置注入是指通过Setter方法来传入具体类的对象, 而接口注入是指通过在接口中申明的业务方法来传入具体类的对象, 这些方法在定时使用的是抽象类型, 在运行时在传入具体类型的对象, 由子类对象来覆盖父类对象.



我们在开发的过程中, 在service层调用service层, 或者manager层的时候, 通过注解@Resource或者@Autowired注入对象的时候, 注入的就是接口, 而不是具体的实现类, 这个就是符合我们这里提到的依赖倒转原则.



其实我们在很多开发的过程中, 特别是在spring的开发过程中, 很多都是使用了设计原则的, 我们只要学习完, 在我们的设计原则中对号入座, 就能掌握了

## 5. 接口分离原则

接口分离原则定义如下:

```
接口分离原则(Interface Segregation Principle, ISP): 使用多个专门的接口, 而不是使用单一的总接口, 即客户端不应该依赖那些它不需要的接口.
```

根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之 相关的方法即可。 这里的“接 口”往往有两种不同的含义:一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象;另外一种是指 某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP 的表达方式以及含义都有所不同:

(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将 直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此 时，这个原则可以叫做“ ”。

(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为, 客户端不需要的行为隐藏起来, 应该为客户端提供尽可能小的单独接口, 而不是提供大的总接口. 在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方 便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端(如 子模块或业务逻辑类)所需的方法即可，这种机制也称为“ ”，即为不同的客户端提供宽窄不同的接口。



其实我们在开发的过程中, 严格遵守我们的开发规范, 一个方法不超过15行代码, 并且给客户端提供接口的时候, 使用单一接口, 这个就不会存在上面的问题, 如果是一个总接口, 可以分成多个接口提供.

## 6. 合成复用原则

合成复用原则又称为聚合复用原则(Composition/Aggregate Reuse Principle, CARP), 其定义如下: 

```
合成复用原则(Composite Reuse Principle, CRP): 尽量使用对象组合, 而不是继承来达到复用的目的
```

合成复用原则就是在一个新的对象里通过关联关系(包括组合关系和聚合关系)来使用一些已有的对象, 使之成为新对象的一部分, 新对象通过委派调用已有对象的方法达到复用功能的目的. 简言之: 复用时要尽量使用组合/聚合关系, 少用继承.

在面向对象设计中, 可以通过两种方法在不同的环境中复用已有的设计和实现, 即通过组合/聚合或通过继承, 但首先应该考虑使用组合/聚合, 组合/聚合可以使系统更加灵活, 降低类与类之间的耦合度, 一个类的变化对其他类造成的影响相对较少; 其次才考虑继承, 使用继承时, 需要严格遵循里式替换原则, 有效使用继承会有助于对问题的理解 降低复杂度, 而滥用继承反而会增阿系统构建和维护的难度以及系统的复杂度 因此需要慎重使用继承复用

通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实也
不得不发生改变;从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性;而且继承只能在
有限的环境中使用(如类没有声明为不能被继承)。

由于组合或聚合关系可以将已有的对象(也可称为成员对象)纳入到新对象中，使之成为新对象的一部分，因此新对
象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作;合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。

一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。"Is-A"是严格的分类学意义上的定义，意思是一个类是另一个类的"一种";而"Has-A"则不同，它表示某一个角色具有某一项责 任。



## 7. 迪米特原则

迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目。迪米特法 则又称为最少知识原则(LeastKnowledge Principle, LKP)，其定义如下:

```
迪米特法则(Law of Demeter, LoD):一个软件实体应当尽可能少地与其他实体发生相互作用。
```

如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特原则可降低系统的耦合度, 使类与类之间保持松散的耦合关系.

迪米特原则嗨哟集中定义形式: 包括: 不要和"陌生人"说话, 只与你的直接朋友通信等, 子迪米特法则中, 对于一个对象, 其朋友包括以下几类: 

1. 当前对下你给自身(this)
2. 以参数形式传入传入到对象中
3. 当前对象的成员对象
4. 当前对象锁创建的对象

以上的任何一个对象, 都可以当成当前对象的朋友, 否则就是"陌生人", 在应用迪米特法则时, 一个对象只能与至二级朋友发生交互, 不要与"陌生人"直接交互, 这样做可以降低系统的耦合度, 一个对象的改变不会给太多其他对象带来影响

迪米特法则要求我们在设计系统时, 应该尽量减少对象之间的交互, 如果两个对象之间不必彼此直接通信, 那么这两个对象就不应当发生任何至二级的相互作用, 如果其中也给对象需要调用另外一个对象的某一个方法的话, 可以通过第三者转发这个调用, 简言之. 就是通过引用一个合理的第三者来降低现有对象之间的耦合度

在迪米特法则运用系统设计中时, 要注意下面的几点, 在类的划分是上, 应当尽量创建松耦合类, 类之间的耦合度越低 就越有利于复用, 一个出在松耦合类一旦被修改, 不会对关联的类造成太大波及; 在类的结构设计上, 每一个类都应当尽量降低其成员变量和成员函数的访问权限; 在类的设计上, 只要有可能, 一个类型应当设计成不变类; 在对其他类的应用上, 一个对象对其他对象的引用应当降到最低.